# Задачи към [Правилото на тройката](./)

## Проста симулация на работа на ОС

Създайте симулация на работата на операционна система, която управлява процеси, системна памет (RAM) и извършва планиране на изпълнението на процесите.

## :gear: Process

Един процес ще съдържа следната информация:

| Член-данна | Стойност | Значение |
|---|---|---|
| pid |	цяло число | Уникален идентификатор на процеса |
| name | динамичен низ | Име на процеса |
| memoryUsage |	цяло число | Количество използвана памет (в MB) |
| priority | Very Low, Low, Medium, High, Very High | Приоритет |
| status | Ready, Running, Waiting, Terminated | Състояние на процеса |
| executionTime | цяло число | Общо време за изпълнение |
| remainingTime | цяло число | Оставащо време (намалява при изпълнение) |

Реализирайте нужните конструктори, деструктори, гетъри и сетъри. Освен тях един **Process** трябва да има реализиран следните методи:

- saveToBinaryFile -> записва информацията за процес в бинарен файл
- loadFromBinaryFile -> прочита информацията за процес от бинарен файл
- print -> принтира информация за процеса

По време на работата ви може да се наложи да реализирате допълнителни методи!

## :clipboard: ProcessManager

Управлява множество от процеси.

| Член-данна | Стойност | Значение |
|---|---|---|
| processes | динамичен-масив | Всички активни процеси в системата |

Реализирайте нужните конструктори, деструктори, гетъри и сетъри. Освен тях един **ProcessManager** трябва да има реализиран следните методи:

- addProcess - Добавя нов процес
- terminateProcess - прекратява процес по подадено pid
- listProcesses - принтира информация за всички текущи процеси
- saveAll / loadAll - записва и зарежда всички процеси от бинарен файл

По време на работата ви може да се наложи да реализирате допълнителни методи!

## :alarm_clock: Scheduler

Планира кои процеси ще се изпълняват и кога, по даден алгоритъм.

| Член-данна | Стойност | Значение |
|---|---|---|
| quantum | цяло число | Времеви квант за изпълнение |
| processManager | ProcessManager | Мениджър на процесите |

Реализирайте нужните конструктори, деструктори, гетъри и сетъри. Освен тях един **Scheduler** трябва да има реализиран следните методи:

- scheduleRoundRobin -> Симулира изпълнението на процесите използвайки Round-Robin алгоритъма, като записва работата си в текстов "scheduler.log" файл.
- schedulePriorityScheduling -> Симулира изпълнението на процесите използвайки Priority Scheduling алгоритъма, като записва работата си в текстов "scheduler.log" файл.
- printLog -> Прочита "scheduler.log" файла и го принтира на конзолата.

По време на работата ви може да се наложи да реализирате допълнителни методи!

### Алгоритъм за планиране: Round-Robin

Scheduler използва Round-Robin алгоритъм, който е един от най-често срещаните в реални операционни системи. Той е справедлив, защото дава еднакво време за изпълнение на всеки процес.

Той работи по следният начин:

1. Всеки процес получава равен отрязък от време (наречен квант, например 3 секунди).
2. Процесите се редят в опашка – FIFO (first-in, first-out).
3. Процесът на първо място се изпълнява за 1 квант:
4. Ако приключи → се премахва от опашката.
5. Ако не приключи → се поставя в края на опашката.
6. Следващият процес поема управлението.
7. Това се повтаря докато всички процеси завършат.

### Алгоритъм за планиране: Priority Scheduling

- Всеки процес има асоцииран приоритет.
- Процесът с най-висок приоритет се изпълнява пръв
- Ако два процеса имат еднакъв приоритет, се използва допълнителна стратегия (напр. FIFO)
- Ще използваме неотнемащия вариант, тоест един процес се изпълнява напълно и след това продължаваме към следващият.

## :battery: ResourceManager

Управлява системните ресурси (RAM паметта).

| Член-данна | Стойност | Значение |
|---|---|---|
| totalMemory | цяло число | Общо налична RAM (в MB) |
| usedMemory | цяло число | Заета в момента RAM памет (в MB) |

Реализирайте нужните конструктори, деструктори, гетъри и сетъри. Освен тях един **ResourceManager** трябва да има реализиран следните методи:

- **allocateMemory** – заделя памет
- **freeMemory** – освобождава памет
- **printResourceStatus** – извежда текущото състояние на паметта

По време на работата ви може да се наложи да реализирате допълнителни методи!

## :green_circle: Основен работен цикъл на програмата

При стартиране на програмата, тя трябва да прочете колко е наличната RAM памет в MB.

След което влиза в безкраен цикъл на изпълняване на четене и изпълняване на команди. На всяка итерация трябва да се принтира следното меню:

```
==== PROCESS MANAGER MENU ====
1. Add new process
2. Print all processes
3. Start scheduling (Round-Robin)
4. Start scheduling (Priority Scheduling)
5. Terminate Process
6. Resource State (RAM)
7. Write processes to binary file
8. Read processes from binary file
0. Exit
==============================
Please choose an option: 
```

### (1) Добавяне на процес

Добавянето на процес става като програмата прочита данните за един процес и проверява дали има достатъчно свободна памет в **ResourceManager**-а. Ако има заделя и създава процеса със статус Ready.

### (2) Извеждане на всички процеси

Принтира информация за всички процеси в табличен вид. Пример"

```
| PID | Name    | RAM | Status | Remaining Time |
|-----|---------|-----|--------|----------------|
| 1   | Chrome  | 200 | Ready  | 6              |
| 2   | Discord | 150 | Ready  | 3              |
```

### (3) Стартиране на планирането (Round-Robin)

Въвежда се стойност на квант в секунди, след което се извършва планирането, записва се в log файла и след това съдържанието на файла се принтира на конзолата.

Примерен изход:
```
[Scheduler Start]
Quantum = 3
Running Chrome (PID 1) for 3s -> remaining: 3
Running Discord (PID 2) for 3s -> remaining: 0 -> Terminated
Running Chrome (PID 1) for 3s -> remaining: 0 -> Terminated
[All processes completed]
```

ВАЖНО: Това планиране афектира актуално заредените процеси, тоест в края на работата на тази функционалност трябва да нямаме процеси.

### (4) Стартиране на планирането (Priority Scheduling)

Извършва се планирането, записва се в log файла и след това съдържанието на файла се принтира на конзолата

ВАЖНО: Това планиране афектира актуално заредените процеси, тоест в края на работата на тази функционалност трябва да нямаме процеси.

### (5) Прекратяване на процес

Въвежда се pid и ако съществува премахва процеса отговарящ на него го от списъка и освобождава паметта.

### (6) Статус на ресурсите

Принтира състоянието на ресурсите.

```
=== Resources ===
Total RAM: 1024 MB
Used RAM: 350 MB
Free RAM: 674 MB
=================
```

### (7) Запис в бинарен файл

Записва процесите в бинарен файл.

### (8) Зареждане от бинарен файл

Зарежда процеси от бинарен файл. Потребителят получава възможност да избере дали заредените процеси ще се добавят към вече съществуващите или ще ги заменят.

### (0) Изход от програмата

Прекратява работата на програмата, като преди да излезне пита потребителя дали той иска процесите да бъдат запазени във файл.
