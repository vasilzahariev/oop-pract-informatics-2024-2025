# Задачи към [Множествено наследяване. Шаблони](./)

## Задачи за множествено наследяване

### P1 (първа задача от второ контролно по ООП на КН 2022 г.)

Да се реализира клас за пътешествие с полет със самолет (AirTravel). Класът съдържа:

- номер на полет (flightNumber) – низ с произволна дължина от тип char*;
- времетраенето на полета (duration) – задава се в минути.

Да се реализира клас за пътешествие с кола (CarTravel). Класът съдържа:

- регистрационен номер на превозно средство (regNumb) – представлява масив от четири цифри;
- брой километри, които ще бъдат изминати (distance);
- времетраене на пътуването с кола (също с име duration) – задава се в минути.

Да се реализира клас за комбинирано пътешествие (CombinedTrip), при което има точно едно пътуване с кола и едно пътуване със самолет. Класът притежава всички характеристики на описаните по-горе класове и две допълнителни полета:

- списък от забележителности, които ще бъдат посетени по време на пътуването (destinations) – представя се чрез динамичен масив от низове от тип char* с произволна дължина;
- свободно време за почивка между пътуванията (freeTime) – задава се в минути.

Да се реализира метод getDuration, който връща общото време за пътешествието, което включва времето за пътуване с кола, това за пътуване със самолет и свободното време. Да се реализира метод print, който извежда цялата информацията за пътешествието на екрана.

### P2 (първа задача от писмен изпит по ООП на КН 2019 г.)

Да се напише програма, която позволява създаване и работа с множество от ястия. За целта да се създаде клас ястие (Dish). Всяко ястие (Dish) се характеризира със:

- Списък от продукти (ingredientsNames) - всеки продукт се задава чрез неговото име с произволна дължина. Списъкът съдържа максимум 100 продукта;
- Време за приготвяне (cookTime) - измерва се в минути. Да се реализира функция print, която извежда информацията за едно ястие на екрана.

За целта на нашата задача различаваме два основни типа ястия:

- Ястие с месо (MeatDish) - съдържа допълнителна член-данна месо (meat), която съдържа името на основния протеин в ястието. Член-данната meat може да приема една от следните стойности: “chicken”, “beef”, “pork”, “duck”. Да се реализира функция print, която извежда собствените и наследените данни за ястието;
- Ястие с морска храна (SeafoodDish) - съдържа допълнителна член-данна морска храна (seafood), която съдържа името на основния протеин в ястието. Член-данната seafood може да бъде име на риба или друг морски дар с произволна дължина. Валидация на стойността на член-данната не е необходима. Да се реализира функция print, която извежда собствените и наследените данни за ястието.

Да се реализира клас SurfAndTurf, представляващ ястие, което комбинира морски дарове и месо. Да се напише функция print, която извежда цялата информация за ястието. Да се реализира главна функция (main), която:

- Създава обект от тип SurfAndTurf,
- Създава указател към Dish и го свързва с динамично създаден обект MeatDish. (Използвайте оператор new)
- Освобождава заделената памет, където е нужно.

## Задачи за шаблони

### P3

Реализирайте функция **map**, която приема масив от произволен тип и функция от по-висок ред, която приема само един параметър от същия произволен тип като масива и променя параметъра по някакъв начин.

Реализирайте функция **filter**, която приема масив от произволен тип и функция от по-висок ред, която ще е предикат. **filter** ще премахва всеки елемент от масива, който не удовлетворява предиката.

Примерна употреба:

``` c++

void multBy2(int& num) {
    num *= 2;
}

bool divBy4(int num) {
    return num % 4 == 0;
}

int main() {
    constexpr std::size_t ARR_SIZE = 5;

    int arr[ARR_SIZE] = { 1, 2, 3, 4, 5 };

    map(arr, ARR_SIZE, multBy2); // 2 4 6 8 10
    filter(arr, ARR_SIZE, divBy4); // 4 8

    return 0;
}

```

### P4

Реализирайте функция за натрупване при масиви **fold** със следната сигнатура:

``` c++

... fold(... arr, std::size_t size, ... op, ... startingValue);

```

където:
- **arr** е масив от произволен тип и **size** е неговата големина
- **op** е бинарна операция, която ще приема типа на **startingValue** и типа на **arr** и ще връща типа на **startingValue**
- **startingValue** е начална стойност, която се подава на op в началото

Примерна употреба:

``` c++

int max2(int firstNum, int secondNum) {
    return std::max(firstNum, secondNum);
}

bool anyEven(bool res, int num) {
    return res || num % 2 == 0;
}

int main() {
    constexpr std::size_t ARR_SIZE = 5;
    int arr[ARR_SIZE] = { 1, 2, 8, 4, 5 };

    std::cout << fold(arr, ARR_SIZE, max2, arr[0]) << std::endl; // 8
    std::cout << std::boolalpha << fold(arr, ARR_SIZE, anyEven, false) << std::endl; // true

    return 0;
}

```

### P5

Да се направи темплейтен клас SortedVector, който има следните функционалности:

- съдържа произволен брой уникални елементи;
- да се добавят нови елементи (поставя се на коректното си място, така че елементите да са сортирани);
- да се премахва елемент на определена позиция;
- да се достъпват елементите във вида SortedVector[3];
- да дава информация за броя елементи;
- да дава информация дали е празен;
- да може да приема функция предикат и да премахва елементите, които не отговарят на него;
- да приема функция и да я прилага на всеки елемент от масива (подсигурете, че елементите ще са сортирани след изпълняването на тази функционалност);
- методи за писане и четене от файлове
