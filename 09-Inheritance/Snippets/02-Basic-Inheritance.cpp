#include <iostream>

/*  Наследяване
    *   Наследяването е друг основен принцип на обектно-ориентираното програмиране.
        То позволява на един клас (наследник) да наследява свойства и методи от друг клас (родител).
        Няследяването е "is-a" отношение.
        
    *   Това е полезно, когато искаме да създадем нов клас, който разширява функционалността на съществуващ клас.
    
    *   Например, можем да имаме клас "Point2D", който представлява двумерна точка, и клас "Point3D", който наследява от "Point2D" и добавя трета координата.

    *   Когато искаме само наследниците да имат достъп до член или функция на родителя, можем да използваме модификатора "protected".
        Това е полезно, когато искаме да защитим член или функция от достъп извън наследниците, но все пак да позволим на наследниците да имат достъп до него.

    *   В C++ наследяването се реализира чрез ключовата дума "public", "protected" или "private", последвана от името на родителския клас.
        Например: class Point3D : public Point2D { ... };
        Различните модификатори на достъп определят как наследникът може да получава достъп до членовете на родителя.
        *   public: наследникът може да получава достъп до публичните и защитените членове на родителя.
        *   protected: наследникът може да получава достъп само до защитените членове на родителя.
        *   private: наследникът не може да получава достъп до членовете на родителя.
    
    *   Важно е да се отбележи, че наследяването не е същото като композиране.
        При наследяването, наследникът получава достъп до членовете на родителя, докато при композиране, композитният клас съдържа обекти на компонентните класове.
        Наследяването позволява на наследника да използва и разширява функционалността на родителя,
        докато композиране позволява на композитния клас да изгражда сложни структури от по-прости компоненти.

    *   Важно е да се отбележи, че наследяването може да доведе до проблеми с многократното наследяване, когато един клас наследява от повече от един родител.
        Това може да доведе до конфликти между членовете на родителите и е важно да се използва внимателно.
*/

class Point2D {
public:
    Point2D() {
        std::cout << "Point2D::Point2D() called" << std::endl;
    }

    Point2D(int x, int y) : m_x{ x }, m_y{ y} {
        std::cout << "Point2D::Point2D(int x, int y) called" << std::endl;
    }

    ~Point2D()
    {
        std::cout << "Point2D::~Point2D() called" << std::endl;
    }

protected:
    int m_x{};
    int m_y{};
};

class Point3D : public Point2D {
public:
    Point3D() {
        std::cout << "Point3D::Point3D() called" << std::endl;
    }

    Point3D(int x, int y, int z) : Point2D{ x, y }, m_z{ z } {
        std::cout << "Point3D::Point3D(int x, int y, int z) called" << std::endl;
    }

    ~Point3D() {
        std::cout << "Point3D::~Point3D() called" << std::endl;
    }
private:
    int m_z{};
};

int main () {
    Point3D point3DOnStack;
    // Point3D point3DWithParameters(1, 2, 3);
    
    // Point3D* dynamicallyAllocatedPoint3D = new Point3D();
    
    return 0;
}
